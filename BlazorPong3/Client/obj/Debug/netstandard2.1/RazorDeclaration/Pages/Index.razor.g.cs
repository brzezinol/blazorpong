#pragma checksum "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\Pages\Index.razor" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "d0d98cb12226574fc710119f1e780ae0350d1166"
// <auto-generated/>
#pragma warning disable 1591
#pragma warning disable 0414
#pragma warning disable 0649
#pragma warning disable 0169

namespace BlazorPong3.Client.Pages
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Components;
#nullable restore
#line 1 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\_Imports.razor"
using System.Net.Http;

#line default
#line hidden
#nullable disable
#nullable restore
#line 2 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\_Imports.razor"
using Microsoft.AspNetCore.Components.Forms;

#line default
#line hidden
#nullable disable
#nullable restore
#line 3 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\_Imports.razor"
using Microsoft.AspNetCore.Components.Routing;

#line default
#line hidden
#nullable disable
#nullable restore
#line 4 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\_Imports.razor"
using Microsoft.AspNetCore.Components.Web;

#line default
#line hidden
#nullable disable
#nullable restore
#line 6 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\_Imports.razor"
using BlazorPong3.Client;

#line default
#line hidden
#nullable disable
#nullable restore
#line 7 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\_Imports.razor"
using BlazorPong3.Client.Shared;

#line default
#line hidden
#nullable disable
#nullable restore
#line 2 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\Pages\Index.razor"
using System.Timers;

#line default
#line hidden
#nullable disable
#nullable restore
#line 3 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\Pages\Index.razor"
using BlazorPong3.Shared;

#line default
#line hidden
#nullable disable
#nullable restore
#line 4 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\Pages\Index.razor"
using Microsoft.JSInterop;

#line default
#line hidden
#nullable disable
#nullable restore
#line 5 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\Pages\Index.razor"
using Microsoft.AspNetCore.SignalR.Client;

#line default
#line hidden
#nullable disable
    [Microsoft.AspNetCore.Components.RouteAttribute("/")]
    public partial class Index : Microsoft.AspNetCore.Components.ComponentBase
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder __builder)
        {
        }
        #pragma warning restore 1998
#nullable restore
#line 47 "C:\Users\Piotrek\source\repos\BlazorPong\BlazorPong3\Client\Pages\Index.razor"
      
    public class PlaneDimension
    {
        public int Width { get; set; }
        public int Height { get; set; }
    }

    [Inject]
    IJSRuntime JS { get; set; }

    [Inject]
    NavigationManager NavigationManager { get; set; }

    int ballTop = 55;
    int ballLeft = 0;
    int ballVelocityX = 4;
    int ballVelocityY = 4;

    static int planeWidth = 0;
    static int planeHeight = 0;

    public string BallTop { get; set; }
    public string BallLeft { get; set; }

    static int _lPaletteTop { get; set; }
    static int _rPaletteTop { get; set; }
    public string lPaletteTop { get; set; }
    public string rPaletteTop { get; set; }

    private string _userInput;
    private string _messageInput;
    static bool _isPlayerOne = false;
    public string PlayerID { get; set; }
    static bool requestPlaneSize = false;
    public bool GameStarted { get; set; } = false;

    System.Timers.Timer runingTimer = new System.Timers.Timer();

    public string UserName { get; set; }

    HubConnection hubConnection;
    List<string> messages = new List<string>();

    public bool IsConnected => hubConnection?.State == HubConnectionState.Connected;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        BallTop = $"{ballTop}px";
        BallLeft = $"{ballLeft}px";

        runingTimer.Interval = 25;
        runingTimer.Elapsed += OnTimerElapsed;

        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/gameHub"))
            .Build();

        hubConnection.On<string, string>(SignalRMessages.RECEIVE, (user, message) =>
        {
            Console.WriteLine($"RECEIVE:{message}");
            HandleReceiveMessage(user, message);
        });

        hubConnection.On<string, string>(SignalRMessages.BALL_POSITION, (user, message) =>
        {
            if (!_isPlayerOne)
            {
                var position = message.Split(';');
                ballLeft = int.Parse(position[0]);
                ballTop = int.Parse(position[1]);
            }
        });

        hubConnection.On<string, string>(SignalRMessages.PLAYER_ID, async (user, message) =>
        {
            Console.WriteLine($"PLAYER_ID:{message}");
            if (message == "1")
            {
                _isPlayerOne = true;
                PlayerID = "1";
            }
            else
            {
                _isPlayerOne = false;
                PlayerID = "2";

                await hubConnection.SendAsync(SignalRMessages.START_GAME, UserName);

                GameStarted = true;

                runingTimer.Start();
            }
        });

        hubConnection.On<string, string>(SignalRMessages.START_GAME, async (user, message) =>
        {
            GameStarted = true;

            runingTimer.Start();
        });

        await hubConnection.StartAsync();
    }

    protected override async void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        if (firstRender)
        {
            if (await JS.InvokeAsync<bool>("enterUserName"))
            {

                var dimensions = await JS.InvokeAsync<PlaneDimension>("getPlaneSize");
                planeWidth = dimensions.Width;
                planeHeight = dimensions.Height;

                ballLeft = planeWidth / 2 - 20;
                ballTop = planeHeight / 2 - 20;

                BallTop = $"{ballTop}px";
                BallLeft = $"{ballLeft}px";

                _lPaletteTop = planeHeight / 2 + 60;
                _rPaletteTop = planeHeight / 2 + 60;
            }
        }
    }

    public void Destroy()
    {
        runingTimer.Stop();
    }

    async void OnTimerElapsed(object sender, ElapsedEventArgs e)
    {
        if (requestPlaneSize)
        {
            requestPlaneSize = false;
            var dimensions = await JS.InvokeAsync<PlaneDimension>("getPlaneSize");
            planeWidth = dimensions.Width;
            planeHeight = dimensions.Height;
        }

        if (_isPlayerOne)
        {
            ballTop += ballVelocityY;
            ballLeft += ballVelocityX;
        }

        BallTop = $"{ballTop}px";
        BallLeft = $"{ballLeft}px";

        lPaletteTop = $"{_lPaletteTop}px;";
        rPaletteTop = $"{_rPaletteTop}px;";

        if (_isPlayerOne)
        {
            //bottom
            if (ballTop + 20 >= planeHeight || ballTop <= 55)
            {
                ballVelocityY *= -1;
            }

            //right
            if (ballLeft + 20 >= planeWidth || ballLeft <= 0)
            {
                ballVelocityX *= -1;
            }

            await SendBallPositionAsync();
        }

        StateHasChanged();
    }

    [JSInvokable]
    public static Task OnWindowResize()
    {
        requestPlaneSize = true;

        return Task.CompletedTask;
    }

    [JSInvokable]
    public static Task OnKeyDown(int key)
    {
        switch (key)
        {
            case 38:
                if (_isPlayerOne)
                {
                    _lPaletteTop -= 5;
                }
                else
                {
                    _rPaletteTop -= 5;
                }
                break;
            case 40:
                if (_isPlayerOne)
                {
                    _lPaletteTop += 5;
                }
                else
                {
                    _rPaletteTop += 5;
                }
                break;
            case 27:
                if (_isPlayerOne)
                {

                }
                else
                {

                }
                break;
        }

        return Task.CompletedTask;
    }

    public async Task StartClient()
    {
        Console.WriteLine($"UserName:{UserName}");
        if (!string.IsNullOrEmpty(UserName))
        {
            await JS.InvokeAsync<bool>("hideUserNameDialog");

            await hubConnection.SendAsync(SignalRMessages.REGISTER, UserName);
        }
        else
        {
            Console.WriteLine($"UserName:{UserName}");
        }
    }

    private void HandleReceiveMessage(string username, string message)
    {
        messages.Add($"{username}:{message}");

        StateHasChanged();
    }

    public async Task SendAsync(string message)
    {
        // check we are connected
        if (hubConnection.State != HubConnectionState.Connected)
            throw new InvalidOperationException("Client not started");
        // send the message
        await hubConnection.SendAsync(SignalRMessages.SEND, UserName, message);
    }

    public async Task SendBallPositionAsync()
    {
        // check we are connected
        if (hubConnection.State != HubConnectionState.Connected)
            throw new InvalidOperationException("Client not started");
        // send the message
        await hubConnection.SendAsync(SignalRMessages.BALL_POSITION, UserName, $"{ballLeft};{ballTop}");
    }

    public async Task StopAsync()
    {
        if (hubConnection.State == HubConnectionState.Connected)
        {
            // disconnect the client
            await hubConnection.StopAsync();
            // There is a bug in the mono/SignalR client that does not
            // close connections even after stop/dispose
            // see https://github.com/mono/mono/issues/18628
            // this means the demo won't show "xxx left the chat" since 
            // the connections are left open
            await hubConnection.DisposeAsync();
            hubConnection = null;
        }
    }

    public async ValueTask DisposeAsync()
    {
        Console.WriteLine("ChatClient: Disposing");
        await StopAsync();
    }


#line default
#line hidden
#nullable disable
    }
}
#pragma warning restore 1591
